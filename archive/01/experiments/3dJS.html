<!DOCTYPE html>
<html>
  <head>
    <title>Canvas 3D</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body style="margin: 0; padding: 0">
    <canvas id="canvas" style="background: #232323"></canvas>
    <script typ="text/javascript" src="../bower_components/kefir/dist/kefir.min.js"></script>
    <script>
      function Cube(origin, size, context) {
        var self = this;
        self.origin = origin;
        self.rotation = [0, 0, 0];
        self.size = size;
        self.squareRadius = Math.ceil(Math.pow((size/2)*(size/2)+(size/2)*(size/2), 0.5));
        self.cubeRadius = Math.ceil(Math.pow(self.squareRadius*self.squareRadius+(size/2)*(size/2), 0.5));

        this.generatePoints = function () {
          self.points = [
            {X: self.origin[0]-self.size/2, Y: self.origin[1]-self.size/2, Z: self.origin[2]-self.size/2},
            {X: self.origin[0]-self.size/2, Y: self.origin[1]-self.size/2, Z: self.origin[2]+self.size/2},
            {X: self.origin[0]-self.size/2, Y: self.origin[1]+self.size/2, Z: self.origin[2]-self.size/2},
            {X: self.origin[0]-self.size/2, Y: self.origin[1]+self.size/2, Z: self.origin[2]+self.size/2},
            {X: self.origin[0]+self.size/2, Y: self.origin[1]-self.size/2, Z: self.origin[2]-self.size/2},
            {X: self.origin[0]+self.size/2, Y: self.origin[1]-self.size/2, Z: self.origin[2]+self.size/2},
            {X: self.origin[0]+self.size/2, Y: self.origin[1]+self.size/2, Z: self.origin[2]-self.size/2},
            {X: self.origin[0]+self.size/2, Y: self.origin[1]+self.size/2, Z: self.origin[2]+self.size/2}
          ];
        };
        this.generateLines = function () {
          self.lines = [
            [self.points[0], self.points[1]],
            [self.points[1], self.points[3]],
            [self.points[3], self.points[2]],
            [self.points[2], self.points[0]],
            [self.points[4], self.points[5]],
            [self.points[5], self.points[7]],
            [self.points[7], self.points[6]],
            [self.points[6], self.points[4]],
            [self.points[0], self.points[4]],
            [self.points[1], self.points[5]],
            [self.points[2], self.points[6]],
            [self.points[3], self.points[7]],
          ];
        };
        this.rotate = function (axes, theta) {
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta);
          self.points = self.points.map(function (point) {
            var x = point.X;
            var y = point.Y;
            var z = point.Z;
            if(axes === 'x'){
              return {X: x, Y: y*cosTheta-z*sinTheta, Z: z*cosTheta+y*sinTheta};
            }else if(axes === 'y'){
              return {X: x*cosTheta-z*sinTheta, Y: y, Z: z*cosTheta+x*sinTheta};
            }else if(axes === 'z'){
              return {X: x*cosTheta-y*sinTheta, Y: y*cosTheta+x*sinTheta, Z: z};
            }
          });
        };
        this.updateRotation = function () {
          this.rotate('x', self.rotation[0]);
          this.rotate('y', self.rotation[1]);
          this.rotate('z', self.rotation[2]);
        };
        this.resize = function (amount) {
          for(var i in self.points){
            var x = self.points[i].X;
            var y = self.points[i].Y;
            var z = self.points[i].Z;

            x < 0 ? self.points[i].X -= amount : self.points[i].X += amount;
            y < 0 ? self.points[i].Y -= amount : self.points[i].Y += amount;
            z < 0 ? self.points[i].Z -= amount : self.points[i].Z += amount;
          }
        };
        this.draw = function () {
          // ctx.clearRect (self.origin[0]-self.cubeRadius,self.origin[1]-self.cubeRadius, self.cubeRadius*2, self.cubeRadius*2);
          for(var i in self.lines){
            context.beginPath();
            context.moveTo(self.lines[i][0].X, self.lines[i][0].Y);
            context.lineTo(self.lines[i][1].X, self.lines[i][1].Y);
            context.lineWidth = 3;
            context.strokeStyle = 'white';
            context.stroke();
          }
        };
        this.update = function () {
          this.generatePoints();
          this.updateRotation();
          this.generateLines();
          this.draw();
        };
      }
    </script>
    <script>
      var canvas = document.getElementById('canvas');
      var ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.translate(window.innerWidth/2, window.innerHeight/2);

      var cube = new Cube([0, 0,0], 240, ctx);
      var rotation = [0.001, 0, 0];
      var run = false;

      cube.update ();

      function update () {
        setInterval(function () {
          ctx.clearRect(-window.innerWidth/2,-window.innerHeight/2,window.innerWidth,window.innerHeight);
          if(run){
            // console.log(cube.origin);
            cube.rotation[0] += rotation[0];
            cube.rotation[1] += rotation[1];
            cube.origin[0] += 0.01;
          }
          cube.update ();
        }, 10);
      }
      update ();

      function cubeInteract (container){
        var startPoint = [0,0];
        var mouseDowns = Kefir.fromEvents(container, 'mousedown');
        var mouseMoves = Kefir.fromEvents(container, 'mousemove');
        var mouseUps = Kefir.fromEvents(container, 'mouseup');
        var scrolls = Kefir.stream(function (emitter) {
          function emitScrollY () {
            emitter.emit(window.scrollY);
          }
          emitScrollY ();
          window.addEventListener('scroll', emitScrollY);
          return function () {
            window.removeEventListener('scroll', emitScrollY);
          };

        }).toProperty ();
        var moves = mouseDowns.flatMap(function() {
          return mouseMoves.takeUntilBy(mouseUps);
        });
        mouseDowns.onValue(function (e) { startPoint = [e.pageX,e.pageY]; run = true; });
        moves.onValue(function (e){
          rotation = [(startPoint[1]-e.pageY)*0.0001, (startPoint[0]-e.pageX)*0.0001,0];
        });
        mouseUps.onValue(function () {run = false; });

        // scrolls.onValue(function (e) {cube.size += e; });
      }
      cubeInteract(canvas);
    </script>
  </body>
</html>
