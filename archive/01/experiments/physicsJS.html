<!DOCTYPE html>
<html>
	<head>
		<title>JS Physics Engine</title>
		<meta name="viewport" content="initial-scale=1, maximum-scale=1">
		<meta http-equiv='Content-type' content='text/html; charset=utf-8'>
		<style>
			* {
				margin: 0;
				padding: 0;
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas" style="background-color: #dfdfdf;"></canvas>

		<script src="../bower_components/jquery/dist/jquery.min.js"></script>
		<script type="text/javascript">
		var canvas = document.getElementById('canvas'),
		  ctx = canvas.getContext('2d'),
		  max_height = $(window).height(),
		  max_width = $(window).width(),
		  spaceHeight = max_height,
		  spaceWidth = max_width,
		  acc = 9.81,
		  dt = 1,
		  balls = {},
		  ballIndex = 0,
		  bounce = 0.7,
		  surfaceResistance = 0.999;

		canvas.width = max_width;
		canvas.height = max_height;
		ctx.fillStyle = '#2F2B27';

		$(window).resize(function() {
		  max_width = window.innerWidth;
		  max_height = window.innerHeight;
		  canvas.width = max_width;
		  canvas.height = max_height;
		});

		var current = [],
		  end = [],
		  trigger;

		$(document).mousedown(function(e) {
		  trigger = true;
		  end = [e.pageX, e.pageY];
		});
		$(document).mousemove(function(e) {
		  current = [e.pageX, e.pageY];
		});
		$(document).mouseup(function(e) {
		  if (trigger) {
		    new Ball(current, [(end[0] - current[0]) / 10, (end[1] - current[1]) / 10], [0, acc], 10, 20);
		    console.log([e.pageX, e.pageY]);
		  }
		  trigger = false;
		});

		function aimArrow(start, stop) {
		  if (trigger) {
		    ctx.beginPath();
		    ctx.moveTo(start[0], start[1]);
		    ctx.lineTo(stop[0], stop[1]);
		    ctx.stroke();
		  }
		}

		function Ball(position, velocity, acceleration, mass, radius) {
		  this.prevPosition = position;
		  this.position = position;
		  this.velocity = velocity;
		  this.acceleration = acceleration;
		  this.mass = radius;
		  this.radius = radius;

		  ballIndex++;
		  balls[ballIndex] = this;
		  this.Id = ballIndex;

		  this.calcAcceleration = function() {
		    this.acceleration[1] = acc / 20;
		  }
		  this.calcVelocity = function() {
		    this.velocity[0] += this.acceleration[0];
		    this.velocity[1] += this.acceleration[1];
		  }
		  this.calcPosition = function() {
		    this.position[0] += this.velocity[0];
		    this.position[1] += this.velocity[1];
		    this.prevPosition = this.position;
		  }
		  this.checkWallColisions = function() {
		    if (this.position[1] >= spaceHeight - this.radius) {
		      this.position[1] = spaceHeight - this.radius;
		      this.velocity[1] *= -bounce;
		      if (this.velocity[1] > -0.1 && this.velocity[1] < 0.1) {
		        this.velocity[1] = 0;

		        this.velocity[0] *= surfaceResistance;
		        if (Math.abs(this.velocity[0]) <= 0.1) {
		          this.velocity[0] = 0;
		        }
		      }
		    } else if (this.position[1] <= this.radius) {
		      this.position[1] = this.radius;
		      this.velocity[1] *= -bounce;
		    }

		    if (this.position[0] <= 0 + this.radius) {
		      this.position[0] = 0 + this.radius;
		      this.velocity[0] *= -bounce;
		    } else if (this.position[0] >= spaceWidth - this.radius) {
		      this.position[0] = spaceWidth - this.radius;
		      this.velocity[0] *= -bounce;
		    }
		  }
		  this.handleParticleColisions = function() {
		      function resolveCollisions(ball1, ball2){
		          var diffX = ball1.position[0] - ball2.position[0];
		          var diffY = ball1.position[1] - ball2.position[1];

		          var length    = diffX * diffX + diffY * diffY;
		          var dist      = Math.sqrt(length);
		          var realDist = dist - (ball1.radius + ball2.radius);

		          var depthX = diffX * (realDist / dist);
		          var depthY = diffY * (realDist / dist);

		          var vel1 = ball1.velocity;
		          var vel2 = ball2.velocity;

		          ball1.position[0] -= depthX * 0.5;
		          ball1.position[1] -= depthY * 0.5;

		          ball2.position[0] += depthX * 0.5;
		          ball2.position[1] += depthY * 0.5;

		          var pr1 = bounce * (diffX*vel1[0]+diffY*vel1[1]) / length;
		          var pr2 = bounce * (diffX*vel2[0]+diffY*vel2[1]) / length;

		          ball1.velocity[0] += pr2 * diffX - pr1 * diffX;
		          ball2.velocity[0] += pr1 * diffX - pr2 * diffX;

		          ball1.velocity[1] += pr2 * diffY - pr1 * diffY;
		          ball2.velocity[1] += pr1 * diffY - pr2 * diffY;
		      }
		      function distanceBetween(point1, point2) {
		        var x = point1[0]-point2[0];
		        var y = point1[1]-point2[1];
		        return Math.pow(x*x+y*y,0.5)
		      }
		      var ball_1 = this;
		      for (i in balls) {
		        var ball_2 = balls[i];
		        var difference = distanceBetween(ball_1.position, ball_2.position)
		        if (difference <= ball_1.radius + ball_2.radius && difference != 0){
		          resolveCollisions(ball_1, ball_2);
		      }
		    }
		  }
		  this.updatePosition = function() {
		    this.calcAcceleration();
		    this.checkWallColisions();
		    this.calcVelocity();
		    this.handleParticleColisions();
		    this.calcPosition();
		  }
		  this.Draw = function() {
		    ctx.beginPath();
		    ctx.arc(this.position[0], this.position[1], this.radius, 0, Math.PI * 2, true);
		    ctx.fill();
		    ctx.closePath();
		  }
		}

		function Updater() {
		  ctx.clearRect(0, 0, max_width, max_height);
		  aimArrow(end, current);
		  for (var i in balls) {
		    balls[i].updatePosition();
		    balls[i].Draw();
		  }
		  requestAnimationFrame(Updater);
		}

		Updater();
		</script>
	</body>
</html>
