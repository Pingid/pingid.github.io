<!DOCTYPE html>
<html>
	<head>
		<title>JS Physics Engine</title>
		<meta name="viewport" content="initial-scale=1, maximum-scale=1">
		<meta http-equiv='Content-type' content='text/html; charset=utf-8'>
		<style>
			* {
				margin: 0;
				padding: 0;
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas" style="background-color: #dfdfdf;"></canvas>

		<script src="../bower_components/jquery/dist/jquery.min.js"></script>
		<script type="text/javascript">
			var canvas = document.getElementById('canvas'),
					ctx = canvas.getContext('2d'),
					max_height = $(window).height(),
					max_width = $(window).width(),
					spaceHeight = max_height,
					spaceWidth = max_width,
					acc = 9.81,
					dt = 1,
					balls = {},
					ballIndex = 0,
					bounce = 0.7,
					surfaceResistance = 0.999,
					GlobalID
			;

			canvas.width = max_width;
			canvas.height = max_height;
			ctx.fillStyle = '#2F2B27';

			$(window).resize(function(){
					max_width = window.innerWidth;
					max_height = window.innerHeight;
					canvas.width = max_width;
					canvas.height = max_height;
			});


			var current = [], end = [], trigger;

			$(document).mousedown(function(e){
					trigger = true;
					end = [e.pageX, e.pageY];
			});
			$(document).mousemove(function(e){
					current = [e.pageX, e.pageY];
			});
			$(document).mouseup(function(e){
					if (trigger){
							new Ball(current, [(end[0]-current[0])/10,(end[1]-current[1])/10], [0,acc],Math.random()*20, 20);
							console.log([e.pageX,e.pageY]);
					}
					trigger = false;
			});


			function findHypot(pos1, pos2){
					var xSqaured = (pos1[0]-pos2[0])*(pos1[0]-pos2[0]);
					var ySquared = (pos1[1]-pos2[1])*(pos1[1]-pos2[1]);
					return Math.sqrt((xSqaured+ySquared));
			}
			function findAngle(pos1, pos2){
					var x = pos1[0]-pos2[0];
					var y = pos1[1]-pos2[1];
					return Math.atan(y/x);
			}
			function aimArrow(start,stop) {
					if (trigger) {
							ctx.beginPath();
							ctx.moveTo(start[0], start[1]);
							ctx.lineTo(stop[0], stop[1]);
							ctx.stroke();
					}
			}
			function Ball(position, velocity, acceleration, mass, radius){
					this.prevPosition = position;
					this.position = position;
					this.velocity = velocity;
					this.acceleration = acceleration;
					this.mass = radius;
					this.radius = radius;


					ballIndex ++;
					balls[ballIndex] = this;
					this.Id = ballIndex;

					this.calcAcceleration = function() {
							this.acceleration[1] = acc/20;
					}
					this.calcVelocity = function() {
							this.velocity[0] += this.acceleration[0];
							this.velocity[1] += this.acceleration[1];
					}
					this.calcPosition = function() {
							this.position[0] += this.velocity[0];
							this.position[1] += this.velocity[1];
							this.prevPosition = this.position;
					}
					this.checkWallColisions = function() {
							if (this.position[1] >= spaceHeight-this.radius){
									this.position[1] = spaceHeight-this.radius;
									this.velocity[1] *= -bounce;
									if(this.velocity[1] > -0.1 && this.velocity[1] < 0.1){
											this.velocity[1] = 0;

											this.velocity[0] *= surfaceResistance;
											if(Math.abs(this.velocity[0]) <= 0.1){
													this.velocity[0] = 0;
											}
									}
							}
							else if (this.position[1] <= this.radius){
									this.position[1] = this.radius;
									this.velocity[1] *= -bounce;
							}

							if (this.position[0] <= 0+this.radius){
									this.position[0] = 0+this.radius;
									this.velocity[0] *= -bounce;
							}
							else if (this.position[0] >= spaceWidth-this.radius){
									this.position[0] = spaceWidth-this.radius;
									this.velocity[0] *= -bounce;
							}
					}
					this.speed = function () {
						return Math.sqrt(this.velocity[0] * this.velocity[0] + this.velocity[1] * this.velocity[1])
					}
					this.energy = function () {
						return (this.mass / 2) * (this.velocity[0] * this.velocity[0] + this.velocity[1] * this.velocity[1])
					}
					this.direction = function () {
						return Math.atan2(this.velocity[1], this.velocity[0]);
					}
					this.updatePosition = function() {
							this.calcAcceleration();
							// this.detectParticleColisions();
							this.checkWallColisions();
							this.calcVelocity();
							this.calcPosition();
					}
					this.Draw = function() {
							ctx.beginPath();
							ctx.arc(this.position[0], this.position[1], this.radius, 0, Math.PI * 2, true);
							ctx.fill();
							ctx.closePath();
					}
			}
			function Updater() {
					ctx.clearRect(0, 0, max_width, max_height);
					aimArrow(end,current);

					for(var i in balls){
							balls[i].updatePosition();
							balls[i].Draw();
					}
					requestAnimationFrame(Updater);
			}
			// setInterval(Updater, dt);


			Updater();
		</script>
	</body>
</html>
